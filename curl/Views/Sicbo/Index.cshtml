@model List<curl.Models.SicboRowViewModel>
@{
    ViewData["Title"] = "SICBO";
}

<div class="container-fluid">
    <div class="d-flex align-items-center justify-content-between mb-3">
        <h2 class="mb-0">SICBO</h2>
        <div class="d-flex gap-2 align-items-center toolbar">
            <span class="badge bg-secondary" id="strategyStatus">Phương pháp: đang phân tích…</span>
            <button id="btnAuto" type="button" class="btn btn-primary">Tự động</button>
            <button id="btnStop" type="button" class="btn btn-outline-secondary">Dừng</button>
            <span class="ms-2 small text-muted">Đúng: <strong id="statCorrect">0</strong> | Sai: <strong id="statWrong">0</strong> | Tỉ lệ: <strong id="statRate">0%</strong></span>
        </div>
    </div>

    <div class="table-responsive" style="max-height:70vh; overflow-y:auto;">
        <table id="sicboTable" class="table table-striped table-bordered align-middle">
            <thead class="table-light sticky">
                <tr>
                    <th scope="col">STT</th>
                    <th scope="col">Đoán</th>
                    <th scope="col">Đ/S</th>
                    <th scope="col">Lịch Sử</th>
                    <th scope="col">Điểm</th>
                    <th scope="col">Tài/Xỉu</th>
                    <th scope="col">Chẵn/Lẻ</th>
                    <th scope="col">Số Bão</th>
                    <th scope="col">Mã ván</th>
                </tr>
            </thead>
            <tbody>
                @foreach (var row in Model)
                {
                    <tr>
                        <td class="col-stt"></td>
                        <td class="col-result">@row.Guess</td>
                        <td class="col-history">@row.Correctness</td>
                        <td>@row.History</td>
                        <td class="col-points">@row.Points</td>
                        <td class="col-tx">@row.TaiXiu</td>
                        <td class="col-cl">@row.ChanLe</td>
                        <td class="col-bao">@row.SoBao</td>
                        <td>@row.MaVan</td>
                    </tr>
                }
            </tbody>
        </table>
    </div>
</div>

@section Scripts {
    <script>
        (function() {
            const btn = document.getElementById('btnAuto');
            const btnStop = document.getElementById('btnStop');
            const tbody = document.querySelector('#sicboTable tbody');
            const statusEl = document.getElementById('strategyStatus');
            let timer = null;
            let currentStrategy = 'hybrid';
            let history = [];
            try { const saved = localStorage.getItem('sicbo_history'); if (saved) history = JSON.parse(saved) || []; } catch {}
            function setStatus(text) { statusEl.textContent = 'Phương pháp: ' + text; }
            function setStrategy(name, reason) {
                currentStrategy = name;
                if (reason) setStatus(`${name} (${reason})`); else setStatus(name);
            }

            function predictNextTX(historyTX) {
                const n = historyTX.length;
                if (n === 0) return '';
                // Tổng hợp tần suất
                let countT = 0, countX = 0;
                for (const s of historyTX) {
                    if (s === 'Tài') countT++; else if (s === 'Xỉu') countX++;
                }
                // Chuỗi cuối
                let last = historyTX[n - 1];
                let streak = 1;
                for (let i = n - 2; i >= 0; i--) {
                    if (historyTX[i] === last) streak++; else break;
                }
                if (streak >= 2) return last; // tiếp diễn chuỗi nếu >=2
                if (countT > countX) return 'Tài';
                if (countX > countT) return 'Xỉu';
                return last; // hòa → theo xu hướng gần nhất
            }

            function getRuns(arr) {
                // Returns array of runs: [{value, length} ...] from oldest->newest
                const runs = [];
                for (const v of arr) {
                    if (!runs.length || runs[runs.length-1].value !== v) {
                        runs.push({ value: v, length: 1 });
                    } else {
                        runs[runs.length-1].length++;
                    }
                }
                return runs;
            }

            function predictNext(method, historyTX) {
                const n = historyTX.length;
                if (n === 0) return '';
                const last = historyTX[n-1];
                const before = historyTX[n-2];
                const runs = getRuns(historyTX);
                const curRun = runs.length ? runs[runs.length-1] : {value: last, length: 1};
                const prevRun = runs.length > 1 ? runs[runs.length-2] : null;

                const majority = (() => {
                    let t=0,x=0; for (const v of historyTX.slice(-50)) { if (v==='Tài') t++; else if (v==='Xỉu') x++; }
                    if (t>x) return 'Tài'; if (x>t) return 'Xỉu'; return last;
                })();

                switch (method) {
                    case 'streak':
                        return curRun.length >= 3 ? curRun.value : majority;
                    case 'alternate':
                        if (n>=4 && historyTX[n-1]!==historyTX[n-2] && historyTX[n-2]!==historyTX[n-3] && historyTX[n-3]!==historyTX[n-4] && historyTX[n-1]===historyTX[n-3] && historyTX[n-2]===historyTX[n-4]) {
                            return last === 'Tài' ? 'Xỉu' : 'Tài';
                        }
                        return majority;
                    case 'break_streak':
                        if (prevRun && prevRun.length>=5 && curRun.length===1 && curRun.value!==prevRun.value) {
                            return curRun.value; // tiếp tục sau khi gãy cầu dài
                        }
                        return majority;
                    case 'two_two':
                        if (n>=4) {
                            const a=historyTX[n-4], b=historyTX[n-3], c=historyTX[n-2], d=historyTX[n-1];
                            if (a===b && c===d && a!==c) {
                                return d=== 'Tài' ? 'Xỉu' : 'Tài';
                            }
                        }
                        return majority;
                    case 'frequency':
                        return majority;
                    case 'five_opposite':
                        if (curRun.length>=5) return curRun.value==='Tài' ? 'Xỉu' : 'Tài';
                        return majority;
                    case 'hybrid':
                    default:
                        // Ưu tiên nhảy 1-1 → bệt >=2 → tần suất
                        if (n>=4 && historyTX[n-1]!==historyTX[n-2] && historyTX[n-2]!==historyTX[n-3] && historyTX[n-3]!==historyTX[n-4] && historyTX[n-1]===historyTX[n-3] && historyTX[n-2]===historyTX[n-4]) {
                            return last === 'Tài' ? 'Xỉu' : 'Tài';
                        }
                        if (curRun.length>=2) return curRun.value;
                        return majority;
                }
            }

            function chooseBestStrategy(txList) {
                // Phân tích 5 cầu (runs) gần nhất để chọn chiến lược
                const runs = getRuns(txList);
                const lastRuns = runs.slice(-5);

                // Helpers
                const n = txList.length;
                const last4 = txList.slice(-4);
                const isAlternate4 = last4.length === 4 && last4[0] !== last4[1] && last4[0] === last4[2] && last4[1] === last4[3];

                const cur = lastRuns[lastRuns.length - 1] || null;
                const prev = lastRuns[lastRuns.length - 2] || null;
                const prev2 = lastRuns[lastRuns.length - 3] || null;

                // 1) Chuỗi 5 đảo: nếu hiện tại >=5 → đoán ngược lại
                if (cur && cur.length >= 5) return { method: 'five_opposite', rate: 1 };

                // 2) Cầu bệt: nếu hiện tại >=4 → theo xu hướng hiện tại
                if (cur && cur.length >= 4) return { method: 'streak', rate: 1 };

                // 3) Cầu gãy: chuỗi trước dài (>=5) vừa gãy (cur.length == 1)
                if (prev && prev.length >= 5 && cur && cur.length === 1 && prev.value !== cur.value) {
                    return { method: 'break_streak', rate: 1 };
                }

                // 4) Cầu 2-2: ... AA BB AA → dự đoán BB
                if (lastRuns.length >= 3) {
                    const a = lastRuns[lastRuns.length - 3];
                    const b = lastRuns[lastRuns.length - 2];
                    const c = lastRuns[lastRuns.length - 1];
                    if (a && b && c && a.value !== b.value && a.value === c.value && a.length >= 2 && b.length >= 2 && c.length >= 2) {
                        return { method: 'two_two', rate: 1 };
                    }
                }

                // 5) Cầu nhảy 1-1: T-X-T-X → đoán ngược ván trước
                if (isAlternate4) return { method: 'alternate', rate: 1 };

                // 6) Hybrid nhẹ: nếu run hiện tại >=2 → theo xu hướng
                if (cur && cur.length >= 2) return { method: 'streak', rate: 1 };

                // 7) Fallback tần suất 50 ván gần nhất
                return { method: 'frequency', rate: 1 };
            }

            async function fetchData() {
                btn.disabled = true;
                try {
                    const r = await fetch('/Sicbo/Fetch');
                    if (!r.ok) {
                        throw new Error('HTTP ' + r.status);
                    }
                    const data = await r.json();

                    // Merge dữ liệu mới vào lịch sử, giữ tối đa 1000 vòng (cũ -> mới)
                    const existing = new Set(history.map(x => x.maVan));
                    for (const it of data) {
                        if (it && it.maVan && !existing.has(it.maVan)) {
                            history.push(it);
                            existing.add(it.maVan);
                        }
                    }
                    // Sắp xếp theo Mã ván (ưu tiên số), và cắt còn tối đa 1000 bản ghi
                    history.sort((a,b) => {
                        const an = Number(a.maVan); const bn = Number(b.maVan);
                        if (!Number.isNaN(an) && !Number.isNaN(bn)) return an - bn;
                        return String(a.maVan).localeCompare(String(b.maVan));
                    });
                    if (history.length > 1000) history = history.slice(history.length - 1000);
                    try { localStorage.setItem('sicbo_history', JSON.stringify(history)); } catch {}

                    // Tạo dự đoán cho từng vòng (đi trước 1 vòng) và một hàng dự đoán cho vòng kế tiếp, dựa trên toàn bộ lịch sử
                    const txList = history.map(x => x.taiXiu);
                    const predictedFor = [];
                    if (txList.length === 0) {
                        setStrategy('frequency', 'khởi tạo (0 ván)');
                    } else {
                        const ai = chooseBestStrategy(txList);
                        setStrategy(ai.method, `phân tích tự động ~${Math.round((ai.rate||1)*100)}%`);
                    }

                    for (let i = 0; i <= txList.length; i++) {
                        const hist = txList.slice(0, i);
                        const chosen = hist.length === 0 ? 'frequency' : chooseBestStrategy(hist).method;
                        predictedFor[i] = predictNext(chosen, hist);
                    }
                    // Loading 5s trước khi dự đoán vòng kế tiếp
                    let nextPrediction = '';
                    await new Promise(res => setTimeout(res, 500)); // nhẹ để UI vẽ bảng trước
                    const predictor = () => {
                        const chosen = txList.length === 0 ? 'frequency' : chooseBestStrategy(txList).method;
                        return predictNext(chosen, txList);
                    };
                    // hiển thị spinner nhẹ 5s (không chặn UI)
                    const start = Date.now();
                    while (Date.now() - start < 5000) {
                        await new Promise(r => setTimeout(r, 100));
                    }
                    nextPrediction = predictor();

                    // Tính lại Số Bão theo toàn bộ lịch sử (Bão → 1,2,3,… → Bão → 1,2,…)
                    let baoCnt = 0;
                    for (const row of history) {
                        const digits = String(row.history || '').replace(/[^0-9]/g, '');
                        if (digits.length >= 3 && digits[0] === digits[1] && digits[1] === digits[2] && digits[0] !== '0') {
                            row._bao = 'Bão';
                            baoCnt = 0;
                        } else {
                            baoCnt += 1;
                            row._bao = String(baoCnt);
                        }
                    }

                    // Render các hàng kết quả: hiển thị dự đoán của chính vòng đó ở cột Đoán
                    let correct=0, wrong=0;
                    let rowsHtml = history.map((row, i) => {
                        const predForThis = predictedFor[i] ?? '';
                        const correctness = predForThis && row.taiXiu ? (predForThis === row.taiXiu ? 'Đúng✅' : 'Sai❌') : '';
                        if (correctness==='Đúng✅') correct++; else if (correctness==='Sai❌') wrong++;
                        return `
                        <tr class="${correctness==='Đúng✅' ? 'row-correct' : ''}">
                            <td class="col-stt">${i+1}</td>
                            <td class="col-result">${predForThis || ''}</td>
                            <td class="col-history">${correctness}</td>
                            <td>${row.history ?? ''}</td>
                            <td class="col-points">${row.points ?? ''}</td>
                            <td class="col-tx">${row.taiXiu ?? ''}</td>
                            <td class="col-cl">${row.chanLe ?? ''}</td>
                            <td class="col-bao">${row._bao ?? row.soBao ?? ''}</td>
                            <td>${row.maVan ?? ''}</td>
                        </tr>`;
                    }).join('');

                    // Hàng dự đoán cho vòng mới nhất (đi trước 1 vòng): chỉ hiển thị ở cột Đoán
                    rowsHtml += `
                        <tr class="table-warning">
                            <td class="col-stt"></td>
                            <td class="col-result">${nextPrediction || ''}</td>
                            <td class="col-history"></td>
                            <td></td>
                            <td class="col-points"></td>
                            <td class="col-tx"></td>
                            <td class="col-cl"></td>
                            <td class="col-bao"></td>
                            <td></td>
                        </tr>`;

                    tbody.innerHTML = rowsHtml || `<tr><td colspan=\"8\" class=\"text-center text-muted\">Chưa có dữ liệu</td></tr>`;

                    // Cập nhật thống kê
                    const total = correct + wrong;
                    document.getElementById('statCorrect').textContent = String(correct);
                    document.getElementById('statWrong').textContent = String(wrong);
                    document.getElementById('statRate').textContent = total>0 ? (Math.round((correct/total)*1000)/10)+'%' : '0%';

                    // Cuộn xuống cuối để hiển thị bản ghi mới nhất
                    const container = document.querySelector('.table-responsive');
                    container.scrollTop = container.scrollHeight;

                    // Fireworks khi có đúng trong đợt tải này
                    if (correct > 0) {
                        showFireworks();
                    }
                } catch (e) {
                    alert('Lỗi tải dữ liệu: ' + e.message);
                } finally {
                    btn.disabled = false;
                }
            }

            function showFireworks() {
                const overlay = document.createElement('div');
                overlay.className = 'fireworks-overlay';
                document.body.appendChild(overlay);
                const colors = ['#ef4444','#f59e0b','#22c55e','#3b82f6','#a855f7'];
                for (let i = 0; i < 24; i++) {
                    const dot = document.createElement('div');
                    dot.className = 'fire-dot';
                    const angle = Math.random() * Math.PI * 2;
                    const radius = 80 + Math.random()*160;
                    dot.style.setProperty('--dx', `${Math.cos(angle)*radius}px`);
                    dot.style.setProperty('--dy', `${Math.sin(angle)*radius}px`);
                    dot.style.left = `${50 + (Math.random()*40-20)}%`;
                    dot.style.top = `${30 + (Math.random()*40-20)}%`;
                    dot.style.background = colors[Math.floor(Math.random()*colors.length)];
                    overlay.appendChild(dot);
                }
                setTimeout(() => overlay.remove(), 900);
            }

            btn.addEventListener('click', () => {
                if (timer) clearInterval(timer);
                fetchData();
                timer = setInterval(fetchData, 5000);
            });
            btnStop.addEventListener('click', () => {
                if (timer) clearInterval(timer);
                timer = null;
            });
            // Người dùng không thể thay đổi phương pháp: đã bỏ select/checkbox
        })();
    </script>
}


